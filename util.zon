{
    "patch": {
        "name": "patch",
        "output": ''
            cp -vr . $out
            echo pwd=$PWD out=$out
            cd $out
            for patch in $patches; do
              patch -p1 -i $patch
            done
        ''
    },
    "fetch": {
        "name": "download",
        "interpreter": "bash",
        "output": ''
            curl -L $url -o $out
            realhash=$(sha256sum $out | cut -d' ' -f1)
            if [ \"$checksum\" != \"$realhash\" ]; then
               echo \"invalid hash:\t  expected: $realhash\n  got:     $checksum\"
               # exit 1
            fi
        ''
    },
    "unpack": {
        "name": "unpack",
        "interpreter": "bash",
        "output": ''
            mkdir source
            tar -C source -xf $archive || unzip -qd source $archive || (
                echo "unknown format"
                exit 2
            )
            entries=( source/* )
            mkdir -p $out
            if [ ${#entries[@]} -eq 1 ] && [ -d \"${entries[0]}\" ]; then
                cp -va \"${entries[0]}/.\" $out
            else
                cp -va source \"$out/\"
            fi
        ''
    },
    "merge": {
        "name": "merge",
        "output": ''
            mkdir -p \"$out/$prefix\"

            for src in $paths; do
                [ -d \"$src\" ] || continue

                find \"$src\" -type f -o -type l | while read -r file; do
                    rel=\"${file#$src/}\"
                    dest=\"$out/$prefix/$rel\"

                    mkdir -p \"$(dirname \"$dest\")\"

                    if [ ! -e \"$dest\" ]; then
                        # Compute relative path from $dest to $file
                        link_target=\"$(realpath --relative-to=\"$(dirname \"$dest\")\" \"$file\")\"
                        ln -s \"$link_target\" \"$dest\"
                    fi
                done
            done
        ''
    }
}